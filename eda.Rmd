---
title: "Métodos de análisis de datos"
author: "Carlos Gomez Sanchez"
date: "16 de noviembre de 2019"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      section_divs: true
    theme: "spacelab"
    highlight: "zenburn"
    code_folding: "hide"
---

<br>
<center style="color: #5d1451;font-size: 250%">
**Melbourne Housing**
</center>
<br>

```{r setup, echo=FALSE, eval=TRUE}
knitr::opts_chunk$set(error = TRUE)
```

```{r librerías, message=FALSE}
library(caret)
library(ggplot2)
library(dplyr)
library(tidyr)
library(knitr)
library(kableExtra)
library(Hmisc)
library(gmodels)
library(RColorBrewer)
library(VIM)
library(mice)
library(wesanderson)
```
<br>

## Lectura y descripción del dataset

<br>
```{r Lectura, echo=FALSE}
houses <- read.csv('melb_data.csv')
cols <- ncol(houses)
rows <- nrow(houses)
```

El presente dataset contiene información acerca del sector inmobiliario en la ciudad de Melbourne. Está compuesto por un total de 21 variables y 13580 observaciones.
A continuación se muestra una tabla con la descripción de cada variable.

```{r Descripción, echo=FALSE}
dfcol <- data.frame(
  'Variable' = c('Rooms', 'Price', 'Method', 'Type', 'SellerG', 'Date', 'Distance', 'Regionname', 'Propertycount', 'Bedroom2', 'Bathroom', 'Car', 'Landsize', 'BuildingArea', 'CouncilArea'),
  'Descripción' = c('Number of rooms', 'Price in dollars', 'S - property sold; SP - property sold prior; PI - property passed in; PN - sold prior not disclosed; SN - sold not disclosed; NB - no bid; VB - vendor bid; W - withdrawn prior to auction; SA - sold after auction; SS - sold after auction price not disclosed. N/A - price or highest bid not available', 'br - bedroom(s); h - house,cottage,villa, semi,terrace; u - unit, duplex; t - townhouse; dev site - development site; o res - other residential', 'Real Estate Agent', ' Date sold', 'Distance from CBD', 'General Region (West, North West, North, North east ...etc)', 'Number of properties that exist in the suburb', 'Scraped of Bedrooms (from different source)', 'Number of Bathrooms', 'Number of carspots', 'Land Size', 'Building Size', 'Governing council for the area')
)
#Faltan por añadir a la tabla:
#Suburb, Address, Rooms, Price, SellerG, Date, Postcode, YearBuilt, Lattitude, Longtitude

dfcol %>%
  kable() %>%
  kable_styling(bootstrap_options = c('striped'), position = 'center')

head(houses, 10)
```

<br>

## División de los datos

<br>

Separaremos el archivo en dos subconjuntos: datos de entrenamiento y datos de validación. 

```{r DivisiónDatos}
trainIndex <- createDataPartition(houses$Price, p = .8, list = FALSE, times = 1)
housesTrain <- houses[ trainIndex,]
housesTest <- houses[-trainIndex,]
```

Ahora, el subconjunto *Train*, con el que trabajaremos inicialmente, está formado por 10865 observaciones. 

<br>

## Análisis exploratorio de datos

<br>


### Resumen numérico de variables cualitativas

<br>
```{r ResumenCualitativas}
VarCualitativas <- housesTrain %>% select_if(Negate(is.numeric))
names(VarCualitativas) # show the variables
str(VarCualitativas) # show the structure
```

A continuación se muestran las tablas de frecuencia para cada una de las variables cualitativas del dataset a excepción de la variable *Address*. Se decide no emplear esta variable ya que se cuenta con otras de localización como son *Regionname*, *CouncilArea* y *Suburb*.

Respecto a la variable *Date* nos parece más adecuado mostrar las frecuencias por meses del año por lo que la separamos en tres variables distintas: *day*, *mounth* y *year*.
```{r DateSeparate}
dateyear <- VarCualitativas %>% separate(Date, c('day','mounth', 'year'),sep = '/')
```

```{r FrecuenciasCualitativas, eval=FALSE}
table_frecuencias <- function(df, columna1, columna2 = 'Frecuencia'){
  knitr::kable(df, caption = title, col.names = c(columna1, columna2)) %>%
    kable_styling(bootstrap_options = 'striped', position = 'center',full_width = T) %>%
    scroll_box(width = "100%", height = "350px")
  
}

table_frecuencias(df= data.frame(table(VarCualitativas$Suburb)),columna1 = 'Suburb')
table_frecuencias(df= data.frame(table(VarCualitativas$Type)),columna1 = 'Type')
table_frecuencias(df= data.frame(table(VarCualitativas$Method)),columna1 = 'Method')
table_frecuencias(df= data.frame(table(dateyear$mounth)),columna1 = 'Mounth')
table_frecuencias(df= data.frame(table(VarCualitativas$CouncilArea)),columna1 = 'CouncilArea')
table_frecuencias(df= data.frame(table(VarCualitativas$Regionname)),columna1 = 'Region')
```

<br>

### Gráficas de barras

<br>
En este apartado se muestran las gráficas de barras correspondientes a las frecuencias anteriores excepto para la variable *Suburb* ya que presenta 314 niveles y no ofrecería una gráfica legible.

```{r paleta32, echo=FALSE}
#Paleta creada a partir de Brewer Dark2
palette34 = c("#1B9E77","#D95F02","#7570B3","#E7298A","#66A61E","#E6AB02","#A6761D", "#666666","#1DA632","#9E1B84","#1B849E","#7CD902","#A61E22","#1EA6A2","#8AE729", "#AEB370","#70B397","#E7E529","#29E786","#292BE7","#E7292B","#B3708D","#AFE602", "#02E6AB","#02AFE6","#92A61D","#771B9E","#1DA676","#1D4DA6","#02D95F","#02D9CB","#D9CB02","#B37570","#B39670")
```

```{r GráficaBarras}
plot_barritas <-function(df, x, bar, title, xlab, ylab = 'Frecuencia'){

  ggplot(data=df, aes(x=x, fill = bar)) + 
    geom_bar(stat="count",position=position_dodge()) +
    scale_fill_manual(values=palette34) +
    labs(title= title,x= xlab, y = ylab, fill=NULL) + 
    theme(axis.text.x=element_blank())
}

plot_barritas(df = housesTrain,x = housesTrain$Type,bar= housesTrain$Type,title ="Número de casas según su tipo",xlab = "Tipo de casa")

plot_barritas(df = housesTrain,x = housesTrain$Method,bar= housesTrain$Method, title ="Número de casas según método de venta", xlab = "Método de venta")

plot_barritas(df = dateyear,x = dateyear$mounth,bar= dateyear$year,title ="Número de casas según mes y año de venta",xlab = "Mes")

plot_barritas(df = housesTrain,x = housesTrain$CouncilArea,bar = housesTrain$CouncilArea, title ="Número de casas por 'CouncilArea'", xlab = "CouncilArea")

plot_barritas(df = housesTrain,x = housesTrain$Regionname,bar = housesTrain$Regionname, title ="Número de casa por región",xlab = "Región")
```

Atendiendo a la salida, tanto numérica como gráfica, observamos que la variable *CouncilArea* presenta una categoría vacía y otra llamada *Unavailable*. Los datos de dichas categorías (10%) los consideramos faltantes y serán imputados en el apartado dedicado a esto.

<br>

### Resumen numérico variables cuantitativas

<br>
```{r ResumenCuantitativas}
VarCuantitativas <- housesTrain %>% select_if(is.numeric)
VarCuantitativas %>% describe()
```

<br>

### Histogramas, densidad, asimetría y apuntamiento

<br>

```{r HistogramaDensidad}
colorDensidad <- wes_palettes$GrandBudapest1[2]
colorNormal <- wes_palettes$GrandBudapest1[3]

plot_histograma <- function(df, xaes){
  
  ggplot(df, aes(x=xaes)) + geom_histogram(aes(y=..density..), colour="black", fill="white") + geom_density(alpha=.2, fill= colorDensidad) +
  stat_function(fun=dnorm, color=colorNormal, 
  args=list(mean=mean(xaes), sd=sd(xaes)))

}

plot_histograma(housesTrain,housesTrain$Distance)
plot_histograma(housesTrain,housesTrain$Price)
plot_histograma(housesTrain,housesTrain$YearBuilt)
plot_histograma(housesTrain,housesTrain$Rooms)
plot_histograma(housesTrain,housesTrain$Bathroom)
plot_histograma(housesTrain,housesTrain$Bedroom2)
plot_histograma(housesTrain,housesTrain$Car)
plot_histograma(housesTrain,housesTrain$Propertycount)
```

Una de las primeras acciones que realizaremos, en vista del resumen numérico y gráfico, es convertir a categóricas las variables *Rooms*, *Bedroom*, *Bathroom* y *Car*. Para los puntos de corte, nos basaremos en las frecuencias mostradas en la función *describe()* que se pueden observar, también, en los picos de las distribuciones de estas variables.

```{r CuantitativaCategorica}
housesTrain[,"Room_grupos"] <- cut(housesTrain$Rooms, breaks = c(0,1,2,3,4,5,6,11), labels = c("0", "1", "2", "3", "4", "5", "6 o más"), include.lowest = TRUE, right = FALSE)

housesTrain[,"Bed_grupos"] <- cut(housesTrain$Bedroom2, breaks = c(0,1,2,3,4,5,6,21), labels = c("0", "1", "2", "3", "4", "5", "6 o más"), include.lowest = TRUE, right = FALSE)

housesTrain[,"Bath_grupos"] <- cut(housesTrain$Bathroom, breaks = c(0,1,2,3,4,5,9), labels = c("0", "1", "2", "3", "4", "5 o más"), include.lowest = TRUE, right = FALSE)

housesTrain[,"Car_grupos"] <- cut(housesTrain$Car, breaks = c(0,1,2,3,4,5,11), labels = c("0", "1", "2", "3", "4", "5 o más"), include.lowest = TRUE, right = FALSE)
```

<br>

## Análisis exploratorio de datos faltantes

<br>


```{r HistFaltantes}
aggr_plot <- aggr(housesTrain, col=c('#666666','#E6AB02'), numbers=TRUE, sortVars=TRUE,
                  labels=names(housesTrain), cex.axis=0.6, gap=3, 
                  ylab=c("Histogram of missing data","Patrón de co-ocurrencia"))

```

La primera decisión que se toma es eliminar las variables *BuildingArea* y *Landsize*. Ambas variables hacen referencia al area o tamaño de un espacio puesto que los valores iguales a cero han de entenderse como datos faltantes. En este sentido para la variable *BuildingArea* hay un 95.3% de datos faltantes y un 98.85% para la variable *Landsize*. De esta manera, el alto número de datos faltantes hace inviable la imputación de los mismos.

Para las otras variables con datos faltantes (*YearBuilt*, *Car* y *CouncilArea*), vamos a comprobar si dichos datos se distribuyen de manera aleatoria.

```{r DistribuciónFaltantes}

```



Examinamos las variables categóricas:

Vemos que Rooms tiene pinta de concentrarse en pocos valores (1, 2, 3?)
Sobre precio y distancia, se concetran en valores pequeños, y son candidatos a aplicar log para convertirlo en normales
Landize y building area es probable que tengan unos outliers muy grandes, habría que verlo por separado.

```{r message=FALSE}
numeric_cols <- c("Rooms", "Price", "Distance", "Landsize", "BuildingArea", "Regionname")
# Con select_if(is.numeric) nos cogeríamos todas las numericas

houses %>% select(numeric_cols) %>%
  na.omit() %>%
  ggpairs(columns=1:5)
```

Vamos a mirar primero la variable prices:



```{r prices}
hist(houses$Rooms)
boxplot(houses$Rooms)
```
```{r}
for (i in 1:nrow(houses)) {
  if (houses[i, "Rooms"] <=2) {
    houses[i, "RoomsCat"] = "entre_1_y_2"
  }
  else if (houses[i, "Rooms"] <=4 & houses[i, "Rooms"] >2) {
    houses[i, "RoomsCat"] = "entre_2_y_4"
  }
  else if (houses[i, "Rooms"] <=6 & houses[i, "Rooms"] >4) {
    houses[i, "RoomsCat"] = "entre_4_y_6"
  }
  else if (houses[i, "Rooms"] <=8 & houses[i, "Rooms"] >6) {
    houses[i, "RoomsCat"] = "entre_6_y_8"
  }
  else{
    houses[i, "RoomsCat"] = "entre_8_y_10"
  }
}
```

```{r}
houses %>% select(c("Price", "RoomsCat")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=RoomsCat)) +
    geom_density()
```


```{r rooms}

houses %>% select(c("Price", "Regionname")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Regionname)) +
    geom_density()

```