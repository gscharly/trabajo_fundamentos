---
title: "Métodos de análisis de datos"
author: "Carlos Gomez Sanchez"
date: "16 de noviembre de 2019"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      section_divs: true
    theme: "spacelab"
    highlight: "zenburn"
    code_folding: "hide"
---

<br>
<center style="color: #5d1451;font-size: 250%">
**Melbourne Housing**
</center>
<br>

```{r setup, echo=FALSE, eval=TRUE}
knitr::opts_chunk$set(error = TRUE)
```

```{r librerías, message=FALSE}
library(caret)
library(dplyr)
library(RColorBrewer)
library(Hmisc)
library(VIM)
library(tidyr)
library(knitr)
library(kableExtra)
library(Hmisc)
library(gmodels)
library(RColorBrewer)
library(VIM)
library(mice)
library(wesanderson)
library(ggplot2)
library(GGally)
library(gridExtra)
library(car)
library(plyr)
library(tidyverse)

set.seed(10)

colorDensidad <- wes_palettes$GrandBudapest1[2]
colorNormal <- wes_palettes$GrandBudapest1[3]
```
<br>

## Lectura y descripción del dataset

<br>
```{r Lectura, echo=FALSE}
houses <- read.csv('./datasets/melb_data.csv')
cols <- ncol(houses)
rows <- nrow(houses)
```

El presente dataset contiene información acerca del sector inmobiliario en la ciudad de Melbourne. Está compuesto por un total de 21 variables y 13580 observaciones.
A continuación se muestra una tabla con la descripción de cada variable.

```{r Descripción, echo=FALSE}
dfcol <- data.frame(
  'Variable' = c('Rooms', 'Price', 'Method', 'Type', 'SellerG', 'Date', 'Distance', 'Regionname', 'Propertycount', 'Bedroom2', 'Bathroom', 'Car', 'Landsize', 'BuildingArea', 'CouncilArea'),
  'Descripción' = c('Number of rooms', 'Price in dollars', 'S - property sold; SP - property sold prior; PI - property passed in; PN - sold prior not disclosed; SN - sold not disclosed; NB - no bid; VB - vendor bid; W - withdrawn prior to auction; SA - sold after auction; SS - sold after auction price not disclosed. N/A - price or highest bid not available', 'br - bedroom(s); h - house,cottage,villa, semi,terrace; u - unit, duplex; t - townhouse; dev site - development site; o res - other residential', 'Real Estate Agent', ' Date sold', 'Distance from CBD', 'General Region (West, North West, North, North east ...etc)', 'Number of properties that exist in the suburb', 'Scraped of Bedrooms (from different source)', 'Number of Bathrooms', 'Number of carspots', 'Land Size', 'Building Size', 'Governing council for the area')
)
#Faltan por añadir a la tabla:
#Suburb, Address, Rooms, Price, SellerG, Date, Postcode, YearBuilt, Lattitude, Longtitude

dfcol %>%
  kable() %>%
  kable_styling(bootstrap_options = c('striped'), position = 'center')

head(houses, 10)
```

<br>

## División de los datos

<br>

Separaremos el archivo en dos subconjuntos: datos de entrenamiento y datos de validación. 

```{r DivisiónDatos}
set.seed(10)
trainIndex <- createDataPartition(houses$Price, p = .8, list = FALSE, times = 1)
housesTrain <- houses[ trainIndex,]
housesTest <- houses[-trainIndex,]
```

Ahora, el subconjunto *Train*, con el que trabajaremos inicialmente, está formado por 10865 observaciones. 

<br>

## Análisis exploratorio de datos

<br>


### Variables categóricas

<br>
```{r ResumenCualitativas}
VarCualitativas <- housesTrain %>% select_if(Negate(is.numeric))
names(VarCualitativas) # show the variables
str(VarCualitativas) # show the structure
```

A continuación se muestran las tablas de frecuencia para cada una de las variables cualitativas del dataset a excepción de la variable *Address*. Se decide no emplear esta variable ya que se cuenta con otras de localización como son *Regionname*, *CouncilArea* y *Suburb*.

Respecto a la variable *Date* nos parece más adecuado mostrar las frecuencias por meses del año por lo que la separamos en tres variables distintas: *day*, *mounth* y *year*.
```{r DateSeparate}
dateyear <- VarCualitativas %>% separate(Date, c('day','month', 'year'), sep = '/')
```

```{r FrecuenciasCualitativas, eval=FALSE}
table_frecuencias <- function(df, columna1, columna2 = 'Frecuencia'){
  knitr::kable(df, caption = title, col.names = c(columna1, columna2)) %>%
    kable_styling(bootstrap_options = 'striped', position = 'center',full_width = T) %>%
    scroll_box(width = "100%", height = "350px")
  
}

table_frecuencias(df= data.frame(table(VarCualitativas$Suburb)),columna1 = 'Suburb')
table_frecuencias(df= data.frame(table(VarCualitativas$Type)),columna1 = 'Type')
table_frecuencias(df= data.frame(table(VarCualitativas$Method)),columna1 = 'Method')
table_frecuencias(df= data.frame(table(dateyear$mounth)),columna1 = 'Month')
table_frecuencias(df= data.frame(table(VarCualitativas$CouncilArea)),columna1 = 'CouncilArea')
table_frecuencias(df= data.frame(table(VarCualitativas$Regionname)),columna1 = 'Region')
```

<br>

#### Gráficas de barras

<br>
En este apartado se muestran las gráficas de barras correspondientes a las frecuencias anteriores excepto para la variable *Suburb* ya que presenta 314 niveles y no ofrecería una gráfica legible.

Podemos observar que las casas tipo h (house, cottage, villa...) son las más numerosas, el método de venta más popular es S (propiedad vendida) y que hay dos años de venta (2016 y 2017) en los que no se venden casas en todos los meses. Además, de las 8 regiones de Melbourne, hay 4 que representan el 95% de casas vendidas (Southern Metropolitan, Northern Metropolitan, Western Metropolitan y Eastern Metropolitan en ese orden)

```{r paleta32, echo=FALSE}
#Paleta creada a partir de Brewer Dark2
palette34 = c("#1B9E77","#D95F02","#7570B3","#E7298A","#66A61E","#E6AB02","#A6761D", "#666666","#1DA632","#9E1B84","#1B849E","#7CD902","#A61E22","#1EA6A2","#8AE729", "#AEB370","#70B397","#E7E529","#29E786","#292BE7","#E7292B","#B3708D","#AFE602", "#02E6AB","#02AFE6","#92A61D","#771B9E","#1DA676","#1D4DA6","#02D95F","#02D9CB","#D9CB02","#B37570","#B39670")
```

```{r GráficaBarras}
plot_barritas <-function(df, x, bar, title, xlab, ylab = 'Frecuencia'){

  ggplot(data=df, aes(x=x, fill = bar)) + 
    geom_bar(stat="count",position=position_dodge()) +
    scale_fill_manual(values=palette34) +
    labs(title= title,x= xlab, y = ylab, fill=NULL) + 
    theme(axis.text.x=element_blank())
}

plot_barritas(df = housesTrain,x = housesTrain$Type,bar= housesTrain$Type,title ="Número de casas según su tipo",xlab = "Tipo de casa")

plot_barritas(df = housesTrain,x = housesTrain$Method,bar= housesTrain$Method, title ="Número de casas según método de venta", xlab = "Método de venta")

plot_barritas(df = housesTrain,x = housesTrain$CouncilArea,bar = housesTrain$CouncilArea, title ="Número de casas por 'CouncilArea'", xlab = "CouncilArea")

plot_barritas(df = housesTrain,x = housesTrain$Regionname,bar = housesTrain$Regionname, title ="Número de casa por región",xlab = "Región")
```

Atendiendo a la salida, tanto numérica como gráfica, observamos que la variable *CouncilArea* presenta una categoría vacía y otra llamada *Unavailable*. Los datos de dichas categorías (10%) los consideramos faltantes y serán imputados en el apartado dedicado a esto.

#### Comparación con Price
Examinamos la variable Price en función de las variables categóricas que tenemos.

__Regionname__

Distribución de precio en función de la región. Western Victoria parece que tiene unos precios más bajos, mientras que Southern Metropolitan y Eastern Metropolitan parece que tienen mayores precios.

```{r fig.width=15, fig.height=6}
housesTrain %>% select(c("Price", "Regionname")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Regionname)) +
  geom_density()
```

```{r fig.width=15, fig.height=6}
housesTrain %>% select(c("Price", "Regionname")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Regionname)) +
  geom_boxplot()
```

__Type__

Solo tenemos 3 tipos (en la descripción aparecen más)

```{r}
housesTrain %>% select(c("Price", "Type")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Type)) +
  geom_density()
```
```{r}
housesTrain %>% select(c("Price", "Type")) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price, colour=Type)) +
  geom_density()
```


```{r}
housesTrain %>% select(c("Price", "Type")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Type)) +
  geom_boxplot()
```

```{r}
housesTrain %>% select(Distance, Type, Price) %>%
  ggplot(aes(y=Price, x=Distance, color=Type)) +
  geom_point()
```

__Method__

```{r}
housesTrain %>% select(c("Price", "Method")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Method)) +
  geom_density()
```
```{r}
housesTrain %>% select(c("Price", "Method")) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price, colour=Method)) +
  geom_density()
```

```{r}
housesTrain %>% select(c("Price", "Method")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Method)) +
  geom_boxplot()
```

__CouncilArea__

```{r fig.width=15, fig.height=4}
housesTrain %>% select(c("Price", "CouncilArea")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=CouncilArea)) +
  geom_boxplot()
```

<br>

### Variables cuantitativas
A continuación, examinaremos las distintas variables numéricas, y su relación con la que será nuestra columna objetivo (Price).

__Resumen numérico__

<br>
```{r ResumenCuantitativas}
VarCuantitativas <- housesTrain %>% select_if(is.numeric)
VarCuantitativas %>% describe()
```

#### Comprobación de datos
Debido a que tenemos variables que representan habitaciones dentro de una casa (*Rooms*, *Bedroom2*, *Bathroom*), vamos a comprobar primero si *Rooms* incluye a las demás. En ese caso, tendría sentido quedarse solo con esa variable, por no ser independientes.

```{r}
housesTrain %>% select(Rooms, Bedroom2, Bathroom) %>%
  filter(Rooms < Bedroom2+Bathroom) %>%
  nrow
```
```{r}
housesTrain %>% select(Rooms, Bedroom2, Bathroom) %>%
  filter(Rooms <= Bedroom2) %>%
  nrow
```
*Rooms* no incluye la suma de *Bedroom2* y *Bathroom*, ya que el 98% de las veces el valor es menor a la suma de ambos.


<br>

#### Histogramas, densidad, asimetría y apuntamiento

<br>

```{r HistogramaDensidad, message=FALSE, warning=FALSE}

plot_histograma <- function(df, xaes, title, xlab, ylab = 'Densidad'){
  
  ggplot(df, aes(x=xaes)) + geom_histogram(aes(y=..density..), colour="black", fill="white") + geom_density(alpha=.2, fill= colorDensidad) +
  stat_function(fun=dnorm, color=colorNormal, 
  args=list(mean=mean(xaes), sd=sd(xaes))) +
  labs(title= title,x= xlab, y = ylab, fill=NULL)
}

plot_histograma(housesTrain,housesTrain$Price, 'Histrograma y densidad de Price', 'Price')
plot_histograma(housesTrain,housesTrain$Distance, 'Histrograma y densidad de Distance', 'Distance')
plot_histograma(housesTrain,housesTrain$YearBuilt, 'Histrograma y densidad de YearBuilt', 'YearBuilt')
plot_histograma(housesTrain,housesTrain$Rooms, 'Histrograma y densidad de Rooms', 'Rooms')
plot_histograma(housesTrain,housesTrain$Bathroom, 'Histrograma y densidad de Bathroom', 'Bathroom')
plot_histograma(housesTrain,housesTrain$Bedroom2, 'Histrograma y densidad de Bedroom2', 'Bedroom2')
plot_histograma(housesTrain,housesTrain$Car, 'Histrograma y densidad de Car', 'Car')
plot_histograma(housesTrain,housesTrain$Propertycount, 'Histrograma y densidad de Propertycount', 'Propertycount')
plot_histograma(housesTrain,housesTrain$BuildingArea, 'Histrograma y densidad de BuildingArea', 'BuildingArea')
plot_histograma(housesTrain,housesTrain$Landsize, 'Histrograma y densidad de Landsize', 'Landsize')
plot_histograma(housesTrain, housesTrain$Lattitude, 'Histrograma y densidad de Lattitude', 'Lattitude')
plot_histograma(housesTrain, housesTrain$Longtitude, 'Histrograma y densidad de Longtitude', 'Longtitude')
```

También es interesante visualizar los boxplots de estas mismas variables.
```{r boxplots}
plot_box <- function(df, col){
  boxplot(df[,col],
     border = '#105e62',
     main = paste('Boxplot', col),
     ylabel=col)
}
cols <- c('Price', 'Distance', 'YearBuilt', 'Rooms', 'Bathroom', 'Bedroom2', 'Car', 'Propertycount', 'BuildingArea', 'Landsize', 'Lattitude', 'Longtitude')
          

for (col in cols) {
  plot_box(housesTrain, col)
}
```

Con toda esta información, ya vemos que tanto BuildingArea (por todos sus valores faltantes) como Landsize (por su distribución y algunos valores iguales a 0) van a necesitar tratamiento especial. Lo veremos más en detalle a la hora de imputar datos faltantes.

Además, vemos que las variables *Rooms*, *Bedroom*, *Bathroom*, y *Car* se concentran en torno a unos pocos valores enteros, por lo que previsiblemente las convertiremos a variables categóricas.

Una de las primeras acciones que realizaremos, en vista del resumen numérico y gráfico, es convertir a categóricas las variables *Rooms*, *Bedroom*, *Bathroom* y *Car*.

<br>
Analizamos ahora distintas variables en función de la variable objetivo (Price).

```{r message=FALSE}
numeric_cols <- c("Rooms", "Distance", "Bedroom2", "Bathroom", "Car", "Price")

housesTrain %>% select(numeric_cols) %>%
  na.omit() %>%
  ggpairs(columns=1:6)
```

Teniendo en cuenta las correlaciones, sería interesante elegir una variable de entre *Rooms*, *Bedroom2* y *Bathroom*, ya que están altamente correladas. Además, parece que la que presenta mayor correlación con *Price* es *Rooms*, por lo que elegimos esta a priori (siempre se puede cambiar y probar en el modelo).

La variable *Distance* no parece que esté muy correlada con ninguna otra. Sin embargo, creemos que puede ser interesante incluirla en los análisis junto con las coordenadas de cada casa (*Lattitude* y *Longtitude*).

```{r message=FALSE}
numeric_cols <- c("Rooms", "Distance", "Car", 'Lattitude', 'Longtitude', "Price")
# Con select_if(is.numeric) nos cogeríamos todas las numericas, pero no se ve nada

housesTrain %>% select(numeric_cols) %>%
  na.omit() %>%
  ggpairs(columns=1:6)
```


__Rooms y Prices__

Rooms se concetra entre 2, 3 y 4 habitaciones. Parece que los precios más altos se alcanzan con 3, 4 y 5 habitaciones, pero los rangos son similares.

```{r}
housesTrain %>%
  select('Rooms', 'Price') %>%
  ggpairs
```
```{r}
housesTrain %>% ggplot(aes(x=Rooms, y=Price)) + geom_point() + geom_smooth(method='lm')
```

Podemos probar a categorizar la variable Rooms:
```{r}
summary(housesTrain$Rooms)
```

```{r}
housesTrain %>% mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>% select(rooms_cat) %>%
  table()
```

```{r}
housesTrain %>% mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>%
  select(Price, rooms_cat) %>%
  ggplot(aes(x=Price, colour=rooms_cat)) +
  geom_density()
```

```{r}
housesTrain %>%
  mutate(rooms_cat = cut2(Rooms, g=4)) %>%
  select(rooms_cat) %>%
  table()
```

```{r}
housesTrain %>% 
  mutate(rooms_cat = cut2(Rooms, g=4)) %>%
  select(Price, rooms_cat) %>%
  ggplot(aes(x=Price, colour=rooms_cat)) +
  geom_density()
```

<br>


__Car y Price__

De nuevo, los valores de *Car* se concentran en 1 o 2, siendo una variable candidata a discretización.
```{r}
housesTrain %>%
  select('Car', 'Price') %>%
  na.omit() %>%
  ggpairs
```

```{r}
summary(housesTrain$Car)
```


```{r}
housesTrain %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  select(car_cat) %>%
  table()
```

```{r}
housesTrain %>% 
  na.omit() %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  select(Price, car_cat) %>%
  ggplot(aes(x=Price, colour=car_cat)) +
  geom_density()

housesTrain %>% 
  na.omit() %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  mutate(log_price=log10(Price)) %>%
  select(log_price, car_cat) %>%
  ggplot(aes(x=log_price, colour=car_cat)) +
  geom_density()
```

__Distance y Price__

Parece que las casas vendidas se concentran a una distancia del centro menor que 15km.
```{r}
housesTrain %>%
  select('Distance', 'Price') %>%
  ggpairs
```

Tanto la variable *Distance* como la variable *Price* tienen sus valores concentrados en la parte baja de la distribución, por lo que una transformación logarítmica podría ser útil. Hay que tener cuidado porque *Distance* tiene unos pocos valores a 0, por lo que se opta por una aplicar la raíz cuadrada (los valores extremos no están tan alejados).
```{r}
housesTrain %>% filter(Distance == 0) %>% nrow
```


```{r}
housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(x=log_distance)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(fill= colorDensidad , alpha=.2)

housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(x=sqrt_distance)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(fill= colorDensidad , alpha=.2)
```
```{r}
p1 <- housesTrain %>% select(Distance) %>%
  ggplot(aes(x=Distance)) + 
  geom_density()

p2 <- housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(x=log_distance)) +
  geom_density()

p3 <- housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(x=sqrt_distance)) +
  geom_density()

grid.arrange(p1, p2, p3, nrow=1)
```


```{r}
p1 <- housesTrain %>% select(Distance) %>%
  ggplot(aes(y=Distance)) + 
  geom_boxplot()

p2 <- housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(y=log_distance)) +
  geom_boxplot()

p3 <- housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(y=sqrt_distance)) +
  geom_boxplot()

grid.arrange(p1, p2, p3, nrow=1)
```


```{r}
housesTrain %>% select(Price) %>%
  filter(Price > 0) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(fill= colorDensidad , alpha=.2)
```
```{r message=FALSE}
housesTrainLog <- housesTrain %>%
  select('Distance', 'Price') %>%
  filter(Price > 0 & Distance > 0) %>%
  mutate(log_price = log10(Price), log_distance=log10(Distance))

 housesTrainLog %>%
  select(log_distance, Price) %>%
  ggpairs
```

También se puede probar una transformación Box-Cox para ver si hay una transformación mejor que la log para igualar la dispersión.

```{r warning=FALSE}
housesTrain %>% select(Distance) %>%
  symbox(~ Distance, data= .)
```
<br>
__Latitud, longitud y Price__
```{r}
housesTrain %>%
  select('Lattitude', 'Longtitude', 'Price') %>%
  ggpairs
```

__Sell date__
Lo primero que hacemos con esta variable será extraer el año, ya que viene en formato dd/MM/yyyy, y probablemente el año nos proporcione más información acerca del precio de venta de la casa.


```{r}
housesTrain$sellYear <- separate(housesTrain, Date, c('day','month', 'year'), sep = '/')$year
housesTrain$sellYear <-factor(housesTrain$year, levels=c("2016", "2017"))
```

Observamos que solo hay 2 años de venta.
```{r}
describe(housesTrain$sellYear)
```

```{r}
housesTrain %>% select(c("Price", "sellYear")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=sellYear)) +
  geom_density()
```


```{r}
price2016 <- housesTrain %>% filter(sellYear==2016) %>% select(Price)
price2017 <- housesTrain %>% filter(sellYear==2017) %>% select(Price)

p1 <- ggplot(price2016, aes(x=Price)) + geom_histogram()
p2 <- ggplot(price2017, aes(x=Price)) + geom_histogram()

grid.arrange(p1, p2, nrow=1)
```


<br>

## Análisis exploratorio de datos faltantes
Hemos visto anteriormente que las variables *YearBuilt*, *BuildingArea* y *Car* tenían valores NAs, y que la variable *Landsize* tenía valores sospechosos (0).
Examinamos primero que % de los registros no tienen estos valores rellenos.

Observamos que cerca del 50% de los registros tienen la variable BuildingArea sin informar, mientras que el 40% no tienen la variable YearBuilt informada. Vemos además que en el 37% de los casos, BuildingArea y YearBuilt faltan simultáneamente. El % de registros con la variable Car vacía es muy pequeño. Además, tenemos 15% de 0 en la variable Landsize, lo que podríamos considerar como valores faltantes.

<br>


```{r HistFaltantes}
aggr_plot <- aggr(housesTrain, col=c('#666666','#E6AB02'), numbers=TRUE, sortVars=TRUE,
                  labels=names(housesTrain), cex.axis=0.6, gap=3, 
                  ylab=c("Histogram of missing data","Patrón de co-ocurrencia"))

```


En resumen:

- Para la variable *BuildingArea*, el 47% de los valores (5145 de 10865) son NaNs, y el 0.11% son 0. En total, tendríamos 47.11% de valores informados, de los cuales la mayoría son 0.

- Para la variable *YearBuilt*, el 40% de los valores son NaNs.

- Para la variable *Landsize*, no hay NaNs, pero el 14.3% de los valores son 0.

- La variable *Car* tiene 49 valores faltantes (0.45%).

<br>

__Relación entre BuildingArea y Landsize informados__
La variable *BuildingArea* podría ser de gran interés a la hora de predecir el precio de venta de una casa. Sin embargo, la gran cantidad de datos faltantes lleva a pensar que una técnica de imputación puede no ser recomendable. Como también se tiene la variable *Landsize*, se procede a comprobar si existe alguna relación entre los valores informados de *BuildingArea* y esta variable, ya que la podríamos utilizar por su bajo número de datos faltantes.

Gráficamente no se ve gran cosa (habría que pasar a log) pero parece que están correladas.
```{r}
housesTrain %>% select(BuildingArea, Landsize) %>% na.omit() %>% ggpairs()
```
```{r}
housesTrain %>% select(BuildingArea, Landsize) %>%
  na.omit() %>%
  filter(Landsize > 0 & BuildingArea > 0) %>%
  mutate(log_landsize = log10(Landsize), log_buildingArea = log10(BuildingArea)) %>%
  select(log_landsize, log_buildingArea) %>% ggpairs()
```
<br>

__Landsize__

Aparte de los valores a 0, esta variable presenta valores muy dispersos. Se puede probar una transformación para verla mejor.
```{r}
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
housesTrain %>% filter(is.na(Landsize)) %>% nrow
```
```{r}
housesLogLandsize <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  filter(Landsize > 0) %>%
  mutate(log_landsize = log10(Landsize)) 

housesLogLandsize %>%
  ggplot(aes(x=log_landsize)) +
  geom_density()
```
```{r}
housesTrain %>% select(Landsize) %>% na.omit() %>%
  symbox(~ Landsize, data= .)
```

Vamos a ver como se distribuyen los valores informados (y faltantes) en función de la localización (latitud y longitud).
```{r message=FALSE}
housesTrain %>% select(Lattitude, Longtitude, Landsize) %>%
  na.omit() %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Lattitude, Longtitude, Landsize, log_landsize) %>%
  ggpairs
```

```{r message=FALSE}
housesTrain %>% filter(is.na(Landsize)) %>% select(Distance,Lattitude, Longtitude, Price) %>% ggpairs()
```
```{r message=FALSE}
housesTrain %>% na.omit() %>% select(Distance,Lattitude, Longtitude, Price) %>% ggpairs()
```

Parece que los valores faltantes de *Landsize* tienen muchos de sus valores en valores bajos de *Lattitude*.
```{r}
housesTrain %>% select(Lattitude, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Lattitude, log_landsize) %>% marginplot()
```

Para la longitud, se distribuyen de forma parecida.
```{r}
housesTrain %>% select(Longtitude, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Longtitude, log_landsize) %>% marginplot()
```

<br>

Si además se examina en función de la distancia, se puede aprecia que los valores faltantes de *Landsize* se dan para valores bajos de *Distance*, es decir, para casas más cercanas al centro de la ciudad.
```{r}
housesTrain %>%
  select(Distance, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Distance, log_landsize) %>% marginplot()
```

Si probamos a imputar con kNN los valores de *Landsize* en función de las coordenadas y la distancia, vemos que los nuevos valores no se alejan demasiado de las distribuciones iniciales.
```{r}
imputationsLandsize <- housesTrain %>% select(Lattitude, Longtitude, Distance, Landsize) %>% VIM::kNN(variable='Landsize')
```


```{r}
imputationsLandsize %>% select(Lattitude, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLandsize %>% select(Longtitude, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLandsize %>% select(Distance, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
```
<br>

Se puede ver mejor si imputamos los valores del logaritmo de *Landsize*:
```{r}
imputationsLogLandsize <- housesTrain %>% mutate(log_landsize=log10(Landsize)) %>%
  select(Lattitude, Longtitude, Distance, log_landsize) %>% VIM::kNN(variable='log_landsize')
```
```{r}
imputationsLogLandsize %>% select(Lattitude, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLogLandsize %>% select(Longtitude, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLogLandsize %>% select(Distance, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
```

```{r message=FALSE}
housesTrain$Landsize_imp <- imputationsLandsize$Landsize
housesTrain %>% 
  mutate(log_landsize = log10(Landsize_imp)) %>%
  select(Lattitude, Longtitude, Distance, log_landsize, Price) %>%
  ggpairs
```

Comparamos la distribución de *Landsize* con valores informados con la generada a través de imputación.


```{r}
p1 <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  ggplot(aes(y=Landsize)) + 
  geom_boxplot()

p2 <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  mutate(log_landsize = log10(Landsize)) %>%
  ggplot(aes(y=log_landsize)) +
  geom_boxplot()

p3 <- imputationsLandsize %>% select(Landsize) %>%
  ggplot(aes(y=Landsize)) + 
  geom_boxplot()

p4 <- imputationsLogLandsize %>% select(log_landsize) %>%
  ggplot(aes(y=log_landsize)) +
  geom_boxplot()

grid.arrange( p2, p4, nrow=1)
```
<br>

__Car__
Para la variable *Car*, solo hay 49 valores faltantes (0.45%). Al ser una variable numérica con valores discretos (solo toma valores enteros desde 0 hasta 8), no parece buena idea utilizar métodos de imputación por regresiones en base a otras variables.

Podemos por un lado tratar de imputarlas basándonos en otras variables y usando kNN:

```{r}
housesTrain %>% select(Rooms, Car)  %>% marginplot()
housesTrain %>% select(Rooms, Car) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
```


```{r}
housesTrain %>% select(YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% marginplot()
housesTrain %>% select(YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
```
```{r}
housesTrain %>% select(Distance, Car)%>% marginplot()
housesTrain %>% select(Distance, Car) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
housesTrain %>% select(Distance, YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% VIM::kNN() %>% select(Distance, Car, Car_imp) %>% marginplot(., delimiter = '_imp')
```

 
Otras dos opciones:
* Borrar esos 49 registros (a riesgo de poder perder algo de información).
* Transformar la variable a categórica e intentar imputar el factor.

Categorizamos la variable (ya vimos que se puede dividir en 2 categorías con aproximadamente el mismo numero de muestras) y utilizamos la función *polyreg* del paquete MICE que permite imputar valores categóricos mediante una regresión politómica. Este método se basa en construir un modelo multinomial para las respuestas categóricas, realizar las predicciones para los valores faltantes y después añadir ruido a estas predicciones.

```{r}
housesTrain$car_cat = housesTrain %>%
  mutate(car_cat = addNA(cut(Car, breaks = c(0,2,9), labels = c("0 o 1 plaza", "2 o más"), include.lowest = TRUE, right = FALSE))) %>%
  select(car_cat) 

housesTrain$rooms_cat = housesTrain%>% 
  mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>% select(rooms_cat) 
```

```{r}
housesTrain %>%
  mutate(car_cat = addNA(cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE))) %>%
  select(car_cat) %>% table
```


```{r}
# ESTO NO ME SALE
library(mice)
cols <- c('rooms_cat', 'Regionname', 'car_cat')
car_imputed = mice(housesTrain[,cols], m=5, method='polyreg', seed=10)
```

Una vez imputado, previsiblemente no habrá cambiado la distribución de la variable al ser un % tan pequeño de datos faltantes.

__YearBuilt__
Al tener tantos registros sin informar, y ser una variable cuantitativa con una distribución que presenta varios tipos, se pretende transformar a una variable categórica que represente intervalos temporales, añadiendo una categoría Unknown a los valores faltantes.
```{r}
housesTrain %>% select(YearBuilt, Price) %>% na.omit() %>% ggpairs
```
Lo primero que hacemos es una rápida comprobación de valores informados. Vemos que hay un outlier en el año 1196. Se establece que cualquier casa que tenga *YearBuilt* por debajo del año de fundación de la ciudad será eliminada.
```{r}
housesTrain %>% select(YearBuilt, Price) %>% na.omit() %>%
  filter(YearBuilt >= 1850) %>% mutate(log_price=log10(Price)) %>% ggpairs
```

Después, se convierte a categórica, y se comprueba su relación con *Price*.

```{r}
year_categories <- housesTrain %>% 
  filter(YearBuilt >= 1850 | is.na(YearBuilt)) %>%
  mutate(year_cat = addNA(cut2(YearBuilt, g=3)))

year_categories %>%
  select(year_cat) %>% table()
```

```{r}
year_categories %>%
  select(Price, year_cat) %>%
  ggplot(aes(x=Price, colour=year_cat)) +
  geom_density()
```
```{r}
year_categories %>%
  select(Price, year_cat) %>%
  ggplot(aes(y=Price, fill=year_cat)) +
  geom_boxplot()
```


## Transformaciones y procesado de variables
A modo de resumen, se contemplan las siguientes transformaciones de las variables cuantitativas disponibles:
* Transformación logarítmica de *Landsize* y *Price* (variable target, cambiaría interpretabilidad, pero puede mejorar predicción)
* Transformación de raíz cuadrada de *Distance*
* Categorización de *Rooms*, *YearBuilt* y *Car*
* Reescalado de variables cuantitativas

```{r}
set.seed(10)
trainIndex <- createDataPartition(houses$Price, p = .8, list = FALSE, times = 1)
housesTrain <- houses[ trainIndex,]
housesTest <- houses[-trainIndex,]

```

```{r cuantitative_transformations}
# Filtros e imputaciones
#housesTrainFinal <- housesTrain
housesTrain$YearBuilt[which(housesTrain$YearBuilt<1850)] <- NA
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
imputationsLandsizeFinal <- housesTrain %>% select(Lattitude, Longtitude, Distance, Landsize) %>% VIM::kNN(variable='Landsize')
imputationsCarFinal <- housesTrain %>% select(Rooms, Car) %>% VIM::kNN(variable='Car')
imputationsCarFinal 

#Necesario para la función de construcción del dataset
housesTrain$LandsizeImp <- imputationsLandsizeFinal %>% select(Landsize) %>% unlist()
housesTrain$CarImp <- imputationsCarFinal %>% select(Car) %>% unlist()
imputationsLandsizeforTest <- housesTrain %>% select(Suburb, Address, Rooms, Type, Price, Method, SellerG, Date, Distance, Postcode, Bedroom2, Bathroom, Car, LandsizeImp, BuildingArea, YearBuilt, CouncilArea, Lattitude, Longtitude, Regionname, Propertycount) 
names(imputationsLandsizeforTest)[names(imputationsLandsizeforTest) == "LandsizeImp"] <- "Landsize"
imputationsCarforTest <- housesTrain %>% select(Suburb, Address, Rooms, Type, Price, Method, SellerG, Date, Distance, Postcode, Bedroom2, Bathroom, CarImp, Landsize, BuildingArea, YearBuilt, CouncilArea, Lattitude, Longtitude, Regionname, Propertycount) 
names(imputationsCarforTest)[names(imputationsCarforTest) == "CarImp"] <- "Car"

# Transformaciones de variables cuantitativas

sqrt_distance <- housesTrain %>% mutate(sqrt_distance = sqrt(Distance)) %>% select(sqrt_distance)
housesTrain$sqrt_distance <- unlist(sqrt_distance)

log_landsize <- imputationsLandsizeFinal %>% mutate(log_landsize=log10(Landsize)) %>% select(log_landsize)
housesTrain$log_landsize <- unlist(log_landsize)
log_price <- housesTrain %>% mutate(log_price = log10(Price)) %>% select(log_price)
housesTrain$log_price <- unlist(log_price)

# Discretización de variables cuantitativas
housesTrain$rooms_cat <- cut(housesTrain$Rooms,  breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE)

housesTrain$year_built_cat <- factor(cut2(housesTrain$YearBuilt, g=2), labels = c("Antigua", "Moderna"))
levels(housesTrain$year_built_cat) <- c(levels(housesTrain$year_built_cat), 'Desconocido')
housesTrain <- housesTrain %>% mutate_at(vars(year_built_cat), ~replace(., is.na(.), 'Desconocido'))

housesTrain$car_cat <-cut(imputationsCarFinal$Car, breaks = c(0,2,9), labels = c("Hasta_1_plaza", "2_o_más_plazas"), include.lowest = TRUE, right = FALSE)

# Estandarización de variables
num_vars <- c('sqrt_distance', 'log_landsize', 'Lattitude', 'Longtitude')
cat_vars <- c('rooms_cat', 'year_built_cat', 'car_cat', 'Regionname', 'Type', 'Method')
housesTrainNum <- housesTrain %>% select(num_vars)
normParam <- preProcess(housesTrainNum)
housesTrainNumNorm <- predict(normParam, housesTrainNum)

housesTrainFinal <- data.frame(housesTrainNumNorm[,num_vars], housesTrain[,cat_vars], housesTrain[, c('Price', 'log_price')])

housesTrainFinal$Regionname = factor(housesTrainFinal$Regionname, levels=c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 'South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'))
#Utilizo la librería plyr
housesTrainFinal$Regionname  = mapvalues(housesTrainFinal$Regionname, from = c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan','South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'), to = c('Southern_Metropolitan', 'Northern_Metropolitan', 'Western_Metropolitan', 'Eastern_Metropolitan','South_Eastern_Metropolitan', 'Eastern_Victoria', 'Northern_Victoria', 'Western_Victoria'))

housesTrainFinal$Method = factor(housesTrainFinal$Method, levels=c('S', 'SP', 'PI', 'VB', 'SA'))
housesTrainFinal$Type = factor(housesTrainFinal$Type, levels=c('h', 'u', 't'))

```


```{r  modeldatasetfunction}

#Función que preprocesa y limpia un dataset dado 
final_dataset_construction <- function(dataset, standarizer, imputationsCarforTest, imputationsLandsizeforTest){
  
  #Preprocesado 
  dataset$YearBuilt[which(dataset$YearBuilt<1850)] <- NA
  dataset$Landsize[which(dataset$Landsize == 0)] <- NA
  datasetCarNARows <- dataset %>% filter(is.na(Car)) %>% nrow()
  datasetCarNA <- dataset %>% filter(is.na(Car))
  datasetLandsizeNARows <- dataset %>% filter(is.na(Landsize)) %>% nrow()
  datasetLandsizeNA <- dataset %>% filter(is.na(Landsize)) 
  
  #Imputación para Car
  imputationsCarforTest <- rbind(imputationsCarforTest,datasetCarNA) 
  imputationsCarFinal <- imputationsCarforTest  %>% select(Rooms, Car) %>% VIM::kNN(variable='Car')
  imputationsCarFinal <- tail(imputationsCarFinal,datasetCarNARows)
  datasetCarNA$Car <- imputationsCarFinal %>% select(Car) %>% unlist()
  dataset <- dataset %>% drop_na(Car)
  dataset <- rbind(dataset,datasetCarNA)
  
  #Imputación para Landsize
  imputationsLandsizeforTest <- rbind(imputationsLandsizeforTest,datasetLandsizeNA) 
  imputationsLandsizeFinal <- imputationsLandsizeforTest  %>% select(Lattitude, Longtitude, Distance, Landsize) %>%        VIM::kNN(variable='Landsize')
  imputationsLandsizeFinal <- tail(imputationsLandsizeFinal,datasetLandsizeNARows)
  datasetLandsizeNA$Landsize <- imputationsLandsizeFinal %>% select(Landsize) %>% unlist()
  dataset <- dataset %>% drop_na(Landsize)
  dataset <- rbind(dataset,datasetLandsizeNA)
  
  #Transformación de variables
  sqrt_distance <- dataset %>% mutate(sqrt_distance = sqrt(Distance)) %>% select(sqrt_distance)
  dataset$sqrt_distance <- unlist(sqrt_distance)
  dataset <- dataset %>% mutate(log_landsize=log10(Landsize))
  log_price <- dataset %>% mutate(log_price = log10(Price)) %>% select(log_price)
  dataset$log_price <- unlist(log_price)
  
  # Discretización de variables cuantitativas
  dataset$rooms_cat <- cut(dataset$Rooms,  breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE)
  
  dataset$year_built_cat <- factor(cut2(dataset$YearBuilt, g=2), labels = c("Antigua", "Moderna"))
  levels(dataset$year_built_cat) <- c(levels(dataset$year_built_cat), 'Desconocido')
  dataset <- dataset %>% mutate_at(vars(year_built_cat), ~replace(., is.na(.), 'Desconocido'))
  
  
  dataset$car_cat <-cut(dataset$Car, breaks = c(0,2,9), labels = c("Hasta_1_plaza", "2_o_más_plazas"), include.lowest = TRUE, right = FALSE)
  
  #Estandarización de variables
  num_vars <- c('sqrt_distance', 'log_landsize', 'Lattitude', 'Longtitude')
  cat_vars <- c('rooms_cat', 'year_built_cat', 'car_cat', 'Regionname', 'Type', 'Method')
  datasetNum <- dataset %>% select(num_vars)
  datasetNumNorm <- predict(standarizer, datasetNum)
  
  
  datasetFinal <- data.frame(datasetNumNorm[,num_vars], dataset[,cat_vars], dataset[, c('Price', 'log_price')])
  
  datasetFinal$Regionname = factor(datasetFinal$Regionname, levels=c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 'South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'))
  #Utilizo la librería plyr
  datasetFinal$Regionname  = mapvalues(datasetFinal$Regionname, from = c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan','South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'), to = c('Southern_Metropolitan', 'Northern_Metropolitan', 'Western_Metropolitan', 'Eastern_Metropolitan','South_Eastern_Metropolitan', 'Eastern_Victoria', 'Northern_Victoria', 'Western_Victoria'))

  datasetFinal$Method = factor(datasetFinal$Method, levels=c('S', 'SP', 'PI', 'VB', 'SA'))
  datasetFinal$Type = factor(datasetFinal$Type, levels=c('h', 'u', 't'))

  
  return(datasetFinal)
  
}

```

```{r}
#Ejemplo de uso de la función
dataTest <- final_dataset_construction(housesTest, normParam,imputationsCarforTest, imputationsLandsizeforTest)
```

```{r}
write.csv(housesTrainFinal, 'train_set.csv', row.names=FALSE)
```
```{r}
train_set = read.csv('train_set.csv')
```

Comprobamos los niveles de los factores de las variables categóricas. Siempre que sea posible, el primer nivel debería asociarse a la categoría con más muestras, ya que previsiblemente será la que menor desviación estándar tenga. Además, si los factores siguen un orden lógico, debería respetarse en los niveles.

Teniendo en cuenta esto, reordenamos las variables *Regionname*, *Method* y *Type*, y forzamos el orden en la variable *rooms_cat*.

```{r}
#Está metido para el housesTrainFinal en la celda de 'cuantitative_transformations'
housesTrain$Regionname = factor(housesTrain$Regionname, levels=c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 
                                                                 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'))
#Utilizo la librería plyr
housesTrain$Regionname  = mapvalues(housesTrain$Regionname, from = c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'), to = c('Southern_Metropolitan', 'Northern_Metropolitan', 'Western_Metropolitan', 'Eastern_Metropolitan', 'Eastern_Victoria', 'Northern_Victoria', 'Western_Victoria'))

housesTrain$Method = factor(housesTrain$Method, levels=c('S', 'SP', 'PI', 'VB', 'SA'))
housesTrain$Type = factor(housesTrain$Type, levels=c('h', 'u', 't'))
```

```{r}
levels(housesTrain$Regionname)
```

```{r}
housesTrain$rooms_cat %>% table()
housesTrain$year_built_cat %>% table()
housesTrain$car_cat %>% table()
housesTrain$Regionname %>% table()
housesTrain$Method %>% table()
housesTrain$Type %>% table()
```

```{r}
levels(housesTrain$rooms_cat)
levels(housesTrain$year_built_cat)
levels(housesTrain$car_cat)
levels(housesTrain$Regionname)
levels(housesTrain$Method)
levels(housesTrain$Type)
```

```{r}
as_tibble(model.matrix(~ housesTrain$sqrt_distance + housesTrain$rooms_cat))
```




```{r message=FALSE}
housesTrain %>% select(sqrt_distance, log_landsize, log_price, rooms_cat) %>% ggpairs(columns=1:3, ggplot2::aes(colour=rooms_cat, alpha=0.1))
```
```{r message=FALSE}
housesTrain %>% select(Lattitude, Longtitude, log_price, rooms_cat) %>% ggpairs(columns=1:3, ggplot2::aes(colour=rooms_cat, alpha=0.1))
```

```{r}
housesTrain %>% select(sqrt_distance, log_landsize, log_price, car_cat) %>% ggpairs(columns=1:3, ggplot2::aes(colour=car_cat, alpha=0.1))
```

```{r}
housesTrain %>% select(sqrt_distance, log_landsize, log_price, year_built_cat) %>% ggpairs(columns=1:3, ggplot2::aes(colour=year_built_cat, alpha=0.1))
```


```{r}
housesTrain %>% select(sqrt_distance, log_price, Type) %>% ggpairs(columns=1:3, ggplot2::aes(colour=Type, alpha=0.1))
```
```{r}
housesTrain %>% select(sqrt_distance, log_landsize, log_price, Method) %>% ggpairs(columns=1:3, ggplot2::aes(colour=Method, alpha=0.1))
```

```{r}
nrow(housesTrain) - (housesTrain %>% filter(is.na(YearBuilt)) %>% nrow())
dataseto <- read.csv('train_set.csv')
dataseto %>% filter(is.na(Regionname)) 

```

```{r}
#Comprobaciones varias y guardado de trainset
housesTest %>% filter(Car > 9) %>% nrow()
housesTrain %>% filter(is.na(car_cat)) 
imputationsCarFinal %>% filter(is.na(Car)) %>% nrow()
housesTrainFinal %>% filter(is.na(car_cat)) 
housesTrainFinal %>% drop_na() %>% nrow()

write.csv(housesTrainFinal, 'train_set.csv', row.names = FALSE)

dat <- read.csv('train_set.csv')
nrow(dat)
dat %>% drop_na() %>% nrow()
dat %>% filter(is.na(year_built_cat)) %>% nrow()
```
```{r}
 housesTrain %>% filter(is.na(YearBuilt)) %>% nrow()

  housesTrain %>% filter(YearBuilt > 1850) %>% select(YearBuilt) %>% na.omit() %>% ggplot(aes((YearBuilt))) + geom_density()
```

```{r}
 housesTrain$YearBuilt[which(housesTrain$YearBuilt<1850)] <- NA
imputationYearBuilt <- housesTrain %>% select(Lattitude, Longtitude, Distance, YearBuilt) %>% VIM::kNN(variable='YearBuilt')

housesTrain$YearBuilt <- imputationYearBuilt %>% select(YearBuilt) %>% unlist()
 housesTrain %>% filter(is.na(YearBuilt)) %>% nrow()

```
```{r}
  housesTrain %>% select(YearBuilt) %>% na.omit() %>% ggplot(aes((YearBuilt))) + geom_density()
```
# Prueba imputación YearBuilt y no categórica

```{r}
# Filtros e imputaciones
#housesTrainFinal <- housesTrain
housesTrain$YearBuilt[which(housesTrain$YearBuilt<1850)] <- NA
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
imputationsLandsizeFinal <- housesTrain %>% select(Lattitude, Longtitude, Distance, Landsize) %>% VIM::kNN(variable='Landsize')
imputationsCarFinal <- housesTrain %>% select(Rooms, Car) %>% VIM::kNN(variable='Car')
imputationYearBuilt <- housesTrain %>% select(Lattitude, Longtitude, Distance, YearBuilt) %>% VIM::kNN(variable='YearBuilt')

#Necesario para la función de construcción del dataset
housesTrain$YearBuilt <- imputationYearBuilt %>% select(YearBuilt) %>% unlist()
housesTrain$LandsizeImp <- imputationsLandsizeFinal %>% select(Landsize) %>% unlist()
housesTrain$CarImp <- imputationsCarFinal %>% select(Car) %>% unlist()
imputationsLandsizeforTest <- housesTrain %>% select(Suburb, Address, Rooms, Type, Price, Method, SellerG, Date, Distance, Postcode, Bedroom2, Bathroom, Car, LandsizeImp, BuildingArea, YearBuilt, CouncilArea, Lattitude, Longtitude, Regionname, Propertycount) 
names(imputationsLandsizeforTest)[names(imputationsLandsizeforTest) == "LandsizeImp"] <- "Landsize"
imputationsCarforTest <- housesTrain %>% select(Suburb, Address, Rooms, Type, Price, Method, SellerG, Date, Distance, Postcode, Bedroom2, Bathroom, CarImp, Landsize, BuildingArea, YearBuilt, CouncilArea, Lattitude, Longtitude, Regionname, Propertycount) 
names(imputationsCarforTest)[names(imputationsCarforTest) == "CarImp"] <- "Car"
imputationsYearforTest <- housesTrain %>% select(Suburb, Address, Rooms, Type, Price, Method, SellerG, Date, Distance, Postcode, Bedroom2, Bathroom, Car, Landsize, BuildingArea, YearBuilt, CouncilArea, Lattitude, Longtitude, Regionname, Propertycount) 



# Transformaciones de variables cuantitativas

sqrt_distance <- housesTrain %>% mutate(sqrt_distance = sqrt(Distance)) %>% select(sqrt_distance)
housesTrain$sqrt_distance <- unlist(sqrt_distance)

log_landsize <- imputationsLandsizeFinal %>% mutate(log_landsize=log10(Landsize)) %>% select(log_landsize)
housesTrain$log_landsize <- unlist(log_landsize)
log_price <- housesTrain %>% mutate(log_price = log10(Price)) %>% select(log_price)
housesTrain$log_price <- unlist(log_price)

# Discretización de variables cuantitativas
housesTrain$rooms_cat <- cut(housesTrain$Rooms,  breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE)

housesTrain$car_cat <-cut(imputationsCarFinal$Car, breaks = c(0,2,9), labels = c("Hasta_1_plaza", "2_o_más_plazas"), include.lowest = TRUE, right = FALSE)

# Estandarización de variables
num_vars <- c('sqrt_distance', 'log_landsize', 'Lattitude', 'Longtitude', 'YearBuilt')
cat_vars <- c('rooms_cat', 'car_cat', 'Regionname', 'Type', 'Method')
housesTrainNum <- housesTrain %>% select(num_vars)
normParam <- preProcess(housesTrainNum)
housesTrainNumNorm <- predict(normParam, housesTrainNum)

housesTrainFinal <- data.frame(housesTrainNumNorm[,num_vars], housesTrain[,cat_vars], housesTrain[, c('Price', 'log_price')])

housesTrainFinal$Regionname = factor(housesTrainFinal$Regionname, levels=c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 'South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'))
#Utilizo la librería plyr
housesTrainFinal$Regionname  = mapvalues(housesTrainFinal$Regionname, from = c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan','South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'), to = c('Southern_Metropolitan', 'Northern_Metropolitan', 'Western_Metropolitan', 'Eastern_Metropolitan','South_Eastern_Metropolitan', 'Eastern_Victoria', 'Northern_Victoria', 'Western_Victoria'))

housesTrainFinal$Method = factor(housesTrainFinal$Method, levels=c('S', 'SP', 'PI', 'VB', 'SA'))
housesTrainFinal$Type = factor(housesTrainFinal$Type, levels=c('h', 'u', 't'))

```

```{r  modeldatasetfunctionyearbuiltnocategorica}

#Función que preprocesa y limpia un dataset dado 
final_dataset_construction_year <- function(dataset, standarizer, imputationsCarforTest, imputationsLandsizeforTest, imputationsYearforTest){
  
  #Preprocesado 
  dataset$YearBuilt[which(dataset$YearBuilt<1850)] <- NA
  dataset$Landsize[which(dataset$Landsize == 0)] <- NA
  datasetCarNARows <- dataset %>% filter(is.na(Car)) %>% nrow()
  datasetCarNA <- dataset %>% filter(is.na(Car))
  datasetLandsizeNARows <- dataset %>% filter(is.na(Landsize)) %>% nrow()
  datasetLandsizeNA <- dataset %>% filter(is.na(Landsize)) 
  datasetYearBuiltNA <- dataset %>% filter(is.na(YearBuilt))
  datasetYearBuiltNARows <- dataset %>% filter(is.na(YearBuilt)) %>% nrow()
  
  #Imputación para Car
  imputationsCarforTest <- rbind(imputationsCarforTest,datasetCarNA) 
  imputationsCarFinal <- imputationsCarforTest  %>% select(Rooms, Car) %>% VIM::kNN(variable='Car')
  imputationsCarFinal <- tail(imputationsCarFinal,datasetCarNARows)
  datasetCarNA$Car <- imputationsCarFinal %>% select(Car) %>% unlist()
  dataset <- dataset %>% drop_na(Car)
  dataset <- rbind(dataset,datasetCarNA)
  
  #Imputación para Landsize
  imputationsLandsizeforTest <- rbind(imputationsLandsizeforTest,datasetLandsizeNA) 
  imputationsLandsizeFinal <- imputationsLandsizeforTest  %>% select(Lattitude, Longtitude, Distance, Landsize) %>%        VIM::kNN(variable='Landsize')
  imputationsLandsizeFinal <- tail(imputationsLandsizeFinal,datasetLandsizeNARows)
  datasetLandsizeNA$Landsize <- imputationsLandsizeFinal %>% select(Landsize) %>% unlist()
  dataset <- dataset %>% drop_na(Landsize)
  dataset <- rbind(dataset,datasetLandsizeNA)
  
  #Imputación para YearBuilt
  imputationsYearforTest <- rbind(imputationsYearforTest,datasetYearBuiltNA)
  imputationsYearBuiltFinal <- imputationsYearforTest %>% select(Lattitude, Longtitude, Distance, YearBuilt) %>% VIM::kNN(variable='YearBuilt')
  imputationsYearBuiltFinal <- tail(imputationsYearBuiltFinal,datasetYearBuiltNARows)
  datasetYearBuiltNA$YearBuilt <- imputationsYearBuiltFinal %>% select(YearBuilt) %>% unlist()
  dataset <- dataset %>% drop_na(YearBuilt)
  dataset <- rbind(dataset,datasetYearBuiltNA)
  
  #Transformación de variables
  sqrt_distance <- dataset %>% mutate(sqrt_distance = sqrt(Distance)) %>% select(sqrt_distance)
  dataset$sqrt_distance <- unlist(sqrt_distance)
  dataset <- dataset %>% mutate(log_landsize=log10(Landsize))
  log_price <- dataset %>% mutate(log_price = log10(Price)) %>% select(log_price)
  dataset$log_price <- unlist(log_price)
  
  # Discretización de variables cuantitativas
  dataset$rooms_cat <- cut(dataset$Rooms,  breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE)
  
  
  dataset$car_cat <-cut(dataset$Car, breaks = c(0,2,9), labels = c("Hasta_1_plaza", "2_o_más_plazas"), include.lowest = TRUE, right = FALSE)
  
  #Estandarización de variables
  num_vars <- c('sqrt_distance', 'log_landsize', 'Lattitude', 'Longtitude', 'YearBuilt')
  cat_vars <- c('rooms_cat', 'car_cat', 'Regionname', 'Type', 'Method')
  datasetNum <- dataset %>% select(num_vars)
  datasetNumNorm <- predict(standarizer, datasetNum)
  
  
  datasetFinal <- data.frame(datasetNumNorm[,num_vars], dataset[,cat_vars], dataset[, c('Price', 'log_price')])
  
  datasetFinal$Regionname = factor(datasetFinal$Regionname, levels=c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan', 'South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'))
  #Utilizo la librería plyr
  datasetFinal$Regionname  = mapvalues(datasetFinal$Regionname, from = c('Southern Metropolitan', 'Northern Metropolitan', 'Western Metropolitan', 'Eastern Metropolitan','South-Eastern Metropolitan', 'Eastern Victoria', 'Northern Victoria', 'Western Victoria'), to = c('Southern_Metropolitan', 'Northern_Metropolitan', 'Western_Metropolitan', 'Eastern_Metropolitan','South_Eastern_Metropolitan', 'Eastern_Victoria', 'Northern_Victoria', 'Western_Victoria'))

  datasetFinal$Method = factor(datasetFinal$Method, levels=c('S', 'SP', 'PI', 'VB', 'SA'))
  datasetFinal$Type = factor(datasetFinal$Type, levels=c('h', 'u', 't'))

  
  return(datasetFinal)
  
}

```


```{r}
test <- final_dataset_construction_year(housesTest,normParam, imputationsCarforTest, imputationsLandsizeforTest, imputationsYearforTest)


```


```{r}

test %>% filter(is.na(log_landsize)) %>% nrow()
test %>% drop_na() %>% nrow()
nrow(test)
#write.csv(test, 'test_yearbuilt.csv', row.names = F)
```


## Selección de variables

En base al exploratorio realizado, hemos visto que no hay ninguna correlación lineal evidente entre las variables cuantitativas y la variable objetivo. Por tanto, vamos a aplicar diversos métodos de selección de variables para encontrar la mejor combinación posible.
