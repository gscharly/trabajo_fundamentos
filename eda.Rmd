---
title: "Métodos de análisis de datos"
author: "Carlos Gomez Sanchez"
date: "16 de noviembre de 2019"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      section_divs: true
    theme: "spacelab"
    highlight: "zenburn"
    code_folding: "hide"
---

<br>
<center style="color: #5d1451;font-size: 250%">
**Melbourne Housing**
</center>
<br>

```{r setup, echo=FALSE, eval=TRUE}
knitr::opts_chunk$set(error = TRUE)
```

```{r librerías, message=FALSE}
library(caret)
library(dplyr)
library(RColorBrewer)
library(Hmisc)
library(VIM)
library(tidyr)
library(knitr)
library(kableExtra)
library(Hmisc)
library(gmodels)
library(VIM)
library(mice)
library(wesanderson)
library(ggplot2)
library(GGally)
library(gridExtra)
library(car)
library(tidyverse)
```
<br>

# Lectura y descripción del dataset

<br>
```{r Lectura, echo=FALSE}
houses <- read.csv('melb_data.csv')
cols <- ncol(houses)
rows <- nrow(houses)
```

El presente dataset contiene información acerca del sector inmobiliario en la ciudad de Melbourne. Está compuesto por un total de 21 variables y 13580 observaciones.
A continuación se muestra una tabla con la descripción de cada variable.

```{r Descripción, echo=FALSE}
dfcol <- data.frame(
  'Variable' = c('Rooms', 'Price', 'Method', 'Type', 'SellerG', 'Date', 'Distance', 'Regionname', 'Propertycount', 'Bedroom2', 'Bathroom', 'Car', 'Landsize', 'BuildingArea', 'CouncilArea'),
  'Descripción' = c('Number of rooms', 'Price in dollars', 'S - property sold; SP - property sold prior; PI - property passed in; PN - sold prior not disclosed; SN - sold not disclosed; NB - no bid; VB - vendor bid; W - withdrawn prior to auction; SA - sold after auction; SS - sold after auction price not disclosed. N/A - price or highest bid not available', 'br - bedroom(s); h - house,cottage,villa, semi,terrace; u - unit, duplex; t - townhouse; dev site - development site; o res - other residential', 'Real Estate Agent', ' Date sold', 'Distance from CBD', 'General Region (West, North West, North, North east ...etc)', 'Number of properties that exist in the suburb', 'Scraped of Bedrooms (from different source)', 'Number of Bathrooms', 'Number of carspots', 'Land Size', 'Building Size', 'Governing council for the area')
)
#Faltan por añadir a la tabla:
#Suburb, Address, Rooms, Price, SellerG, Date, Postcode, YearBuilt, Lattitude, Longtitude

dfcol %>%
  kable() %>%
  kable_styling(bootstrap_options = c('striped'), position = 'center')

head(houses, 10)
```

<br>

# División de los datos

<br>

Separaremos el archivo en dos subconjuntos: datos de entrenamiento y datos de validación. 

```{r DivisiónDatos}
set.seed(10)
trainIndex <- createDataPartition(houses$Price, p = .8, list = FALSE, times = 1)
housesTrain <- houses[ trainIndex,]
housesValidation <- houses[-trainIndex,]
```

Ahora, el subconjunto *Train*, con el que trabajaremos inicialmente, está formado por 10865 observaciones. 

<br>

# Análisis exploratorio de datos

<br>

## Resumen numérico variables cualitativas

<br>

```{r ResumenCualitativas}
VarCualitativas <- housesTrain %>% select_if(Negate(is.numeric))
str(VarCualitativas)
```
<br>

### Tablas de frecuencias

<br>

A continuación se muestran las tablas de frecuencia para cada una de las variables cualitativas del dataset a excepción de la variable *Address*. Se decide no emplear esta variable ya que se cuenta con otras de localización como son *Regionname*, *CouncilArea* y *Suburb*.

Respecto a la variable *Date* nos parece más relevante mostrar las frecuencias por meses del año por lo que la separamos en tres variables distintas: *day*, *mounth* y *year*.

```{r DateSeparate}
VarCualitativas <- VarCualitativas %>% separate(Date, c('Day','Month', 'Year'), sep = '/')
```

```{r FrecuenciasCualitativas}
tabla_frecuencias <- function(df, columna1, columna2 = 'Frecuencia'){
  if(length(df) > 11){
    knitr::kable(df, col.names = c(columna1, columna2)) %>%
      kable_styling(bootstrap_options = 'striped', position = 'center',full_width = T)
      %>%scroll_box(width = "100%", height = "350px")
  }
  else{
    knitr::kable(df, col.names = c(columna1, columna2)) %>%
      kable_styling(bootstrap_options = 'striped', position = 'center',full_width = T)
  }
}

for (var in colnames((VarCualitativas)[c(1,3,4,7,8,9,10)])){
  print(tabla_frecuencias(df = data.frame(table(VarCualitativas[var])), columna1 = var))
}
```

<br>

### Gráficas de barras

<br>
En este apartado se muestran las gráficas de barras correspondientes a las frecuencias anteriores excepto para la variable *Suburb* ya que presenta 314 niveles y no ofrecería una gráfica legible.

Podemos observar que las casas tipo h (house, cottage, villa...) son las más numerosas, el método de venta más popular es S (propiedad vendida) y que hay dos años de venta (2016 y 2017) en los que no se venden casas en todos los meses. Además, de las 8 regiones de Melbourne, hay 4 que representan el 95% de casas vendidas (Southern Metropolitan, Northern Metropolitan, Western Metropolitan y Eastern Metropolitan en ese orden)

```{r paleta32, echo=FALSE}
#Paleta creada a partir de Brewer Dark2
palette34 = c("#1B9E77","#D95F02","#7570B3","#E7298A","#66A61E","#E6AB02","#A6761D", "#666666","#1DA632","#9E1B84","#1B849E","#7CD902","#A61E22","#1EA6A2","#8AE729", "#AEB370","#E7E529","#70B397","#29E786","#292BE7","#E7292B","#B3708D","#AFE602", "#02E6AB","#02AFE6","#92A61D","#771B9E","#1DA676","#1D4DA6","#02D95F","#02D9CB","#D9CB02","#B37570","#B39670")
```

```{r GráficaBarras}
plot_barras <-function(df = VarCualitativas, x, bar, xlab, ylab = 'Frecuencia'){
  ggplot(data=df, aes(x=x, fill = bar)) + 
    geom_bar(stat="count",position=position_dodge()) +
    scale_fill_manual(values=palette34) +
    labs(x= xlab, y = ylab, fill=NULL) + 
    theme(axis.text.x=element_blank())
}

xlab_barras <- c('Tipo de vivienda', 'Método de venta', 'CouncilArea', 'Región')
var_barras <- colnames((VarCualitativas)[c(3,4,9,10)])
i <- 1

for (var in var_barras){
  xaes_var <- VarCualitativas %>% select(var)
  print(plot_barras(x = unlist(xaes_var),bar= unlist(xaes_var), xlab =  var))
  i <- i + 1
}

plot_barras(x = VarCualitativas$Month,bar= VarCualitativas$Year, xlab = 'Month')
```

Atendiendo a la salida, tanto numérica como gráfica, observamos que la variable *CouncilArea* presenta una categoría vacía y otra llamada *Unavailable*. Los datos de dichas categorías (10%) los consideramos faltantes y serán imputados en el apartado dedicado a esto.

```{r UnavailableCouncil}
housesTrain$CouncilArea[which(housesTrain$CouncilArea == '')] <- 'Unavailable'
```

<br>

## Resumen numérico variables cuantitativas

<br>

```{r ResumenCuantitativas}
VarCuantitativas <- housesTrain %>% select_if(is.numeric)
VarCuantitativas %>% describe()
```

<br>

### Histogramas, densidad, asimetría y apuntamiento

<br>

A continuación obserbamos las distribuciones para cada variable cuantitativa a través de sus histogramas.

```{r HistogramaDensidad}
colorDensidad <- brewer.pal(n = 4, name = 'Dark2')[4]
colorNormal <- wes_palettes$GrandBudapest2[4]

plot_histograma <- function(df = housesTrain, dat, xlab, ylab = "Densidad", xaes){
  ggplot(df, aes(x=xaes, label = curt), na.omit = TRUE) + geom_histogram(aes(y=..density..), colour="black", fill="white") + geom_density(alpha=.2, fill= colorDensidad) + theme_light () +
  stat_function(fun=dnorm, color=colorNormal, lwd = 1.3,
  args=list(mean=mean(xaes), sd=sd(xaes)))  + labs(x= xlab, y = ylab) + 
  annotate(geom = 'text', label = dat, hjust = 0, vjust = 1)

}
variables_not_geo <- colnames(VarCuantitativas)[-c(11,12,13)]
for (var in variables_not_geo){
  xaes_var <- VarCuantitativas %>% select(var)
  curt <- round(kurtosis(VarCuantitativas[var], na.rm = TRUE), 2)
  asim <- round(skewness(VarCuantitativas[var], na.rm = TRUE), 2)
  dat <- toString(cat("Curtosis = ",curt,"/ Asimetría",asim))
  print(plot_histograma(dat = dat, xlab = var, xaes = unlist(xaes_var)))
}
```

<br>

### Gráficos de cajas

<br>

Es interesante también visualizar los boxplots de estas mismas variables.

```{r boxplots}
colorBox <- brewer.pal(n = 4, name = 'Dark2')[3]
plot_box <- function(df = VarCuantitativas, yaes){
  ggplot(df, aes(y=yaes)) + geom_boxplot(na.rm = TRUE, colour = colorBox)
                                              
}

cols <- colnames(VarCuantitativas)[-4]
          
for (col in cols) {
  yaes_var <- VarCuantitativas %>% select(col)
  print(plot_box(yaes = unlist(yaes_var)))
}
```

Con toda esta información, ya vemos que tanto BuildingArea (por todos sus valores faltantes) como Landsize (por su distribución y algunos valores iguales a 0) van a necesitar tratamiento especial. Lo veremos más en detalle a la hora de imputar datos faltantes.

Además, vemos que las variables *Rooms*, *Bedroom*, *Bathroom*, y *Car* se concentran en torno a unos pocos valores enteros, por lo que previsiblemente las convertiremos a variables categóricas.

Por otro lado, debido a que tenemos variables que representan habitaciones dentro de una casa (*Rooms*, *Bedroom2*, *Bathroom*), vamos a comprobar primero si *Rooms* incluye a las demás.

```{r ComprobacionRooms}
housesTrain %>% select(Rooms, Bedroom2, Bathroom) %>%
  filter(Rooms < Bedroom2+Bathroom) %>%
  nrow

housesTrain %>% select(Rooms, Bedroom2, Bathroom) %>%
  filter(Rooms <= Bedroom2) %>%
  nrow
```

*Rooms* no incluye la suma de *Bedroom2* y *Bathroom*, ya que el 98% de las veces el valor es menor a la suma de ambos.

<br>

## Análisis multivariante

<br>

Siguiendo con nuestro objetivo principal, es decir predecir el precio de una vivienda en base a sus características, vamos a analizar la relación de las variables del dataset con respecto a la variable *Price*. En algunos casos, tomamos el logarítmo o la raíz cuadrada de *Price* con el fin de hacer las gráficas más legibles.

<br>

### Variables cualitativas

<br>

Empezaremos examinando la variable Price en función de las variables categóricas que tenemos. 

__Regionname__

Distribución de precio en función de la región. Western Victoria parece que tiene unos precios más bajos, mientras que Southern Metropolitan y Eastern Metropolitan (¿?) parece que tienen mayores precios.

```{r RegionPrice fig.width=15, fig.height=6}
housesTrain %>% select(c("Price", "Regionname")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Regionname)) +
  geom_density()

housesTrain %>% select(c("Price", "Regionname")) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price, colour=Regionname)) +
  geom_density()

housesTrain %>% select(c("Price", "Regionname")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Regionname)) +
  geom_boxplot()
```

__Type__

```{r TypePrice fig.width=15, fig.height=6}
housesTrain %>% select(Distance, Type, Price) %>%
  ggplot(aes(y=Price, x=Distance, color=Type)) +
  geom_point()

housesTrain %>% select(c("Price", "Type")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Type)) +
  geom_density()

housesTrain %>% select(c("Price", "Type")) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price, colour=Type)) +
  geom_density()

housesTrain %>% select(c("Price", "Type")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Type)) +
  geom_boxplot()
```

__Method__

```{r PriceMethod}
housesTrain %>% select(c("Price", "Method")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=Method)) +
  geom_density()

housesTrain %>% select(c("Price", "Method")) %>%
  mutate(log_price = log10(Price)) %>%
  ggplot(aes(x=log_price, colour=Method)) +
  geom_density()

housesTrain %>% select(c("Price", "Method")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=Method)) +
  geom_boxplot()
```

__CouncilArea__

```{r fig.width=15, fig.height=4}
housesTrain %>% select(c("Price", "CouncilArea")) %>%
  na.omit() %>%
  ggplot(aes(y=Price, fill=CouncilArea)) +
  geom_boxplot()
```

<br>

### Variables cuantitativas

<br>

A continuación, examinaremos las distintas variables numéricas, y su relación con la que será nuestra columna objetivo (Price).

```{r message=FALSE}

numeric_cols <- c("Rooms", "Distance", "Bedroom2", "Bathroom", "Car", "Price")

VarCuantitativas %>% select(numeric_cols) %>%
  na.omit() %>%
  ggpairs(columns=1:6)

numeric_cols2 <- c("Landsize", "YearBuilt", 'Lattitude', 'Longtitude', "Price")

VarCuantitativas %>% select(numeric_cols2) %>%
  na.omit() %>%
  ggpairs(columns=1:5)

```

Teniendo en cuenta las correlaciones, sería interesante elegir una variable de entre *Rooms*, *Bedroom2* y *Bathroom*, ya que están altamente correladas. A priori, parece que *Rooms* es la elegida ya que presenta mayor correlación con *Price*. No obstante lo probaremos más adelante en el modelo.

Por otra parte, se observa que la variable *Distance* está debilmente correlada las demás. Sin embargo, basándonos en el dominio, creemos que la distancia al centro de la ciudad sí puede ser una variable interesante a ver, posteriormente, qué papel juega en el modelo.

__Rooms y Prices__

Rooms se concetra entre 2, 3 y 4 habitaciones. Parece que los precios más altos se alcanzan con 3, 4 y 5 habitaciones, pero los rangos son similares.

```{r RoomsPrice}
housesTrain %>%
  select('Rooms', 'Price') %>%
  ggpairs
```
Dada la gáfica de distribución de la variable *Rooms* se observa como los valores se concentran en unos puntos. A la hora de discretizarla, probaremos a categorizarla en 3 y 4 grupos para observar cómo se comporta con respecto a *Price*.

```{r Rooms3Grupos}
housesTrain %>% mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>% select(rooms_cat) %>%
  table()

housesTrain %>% mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>%
  select(Price, rooms_cat) %>%
  ggplot(aes(x=Price, colour=rooms_cat)) +
  geom_density()
```

```{r Rooms4Grupos}
housesTrain %>%
  mutate(rooms_cat = cut2(Rooms, g=4)) %>%
  select(rooms_cat) %>%
  table()

housesTrain %>% 
  mutate(rooms_cat = cut2(Rooms, g=4)) %>%
  select(Price, rooms_cat) %>%
  ggplot(aes(x=Price, colour=rooms_cat)) +
  geom_density()
```

__Car y Price__

Los valores de *Car* se concentran en 1 o 2 por lo que, al igual que la anterior variable, es candidata a discretización.
```{r CarPrice}
housesTrain %>%
  select('Car', 'Price') %>%
  na.omit() %>%
  ggpairs
```

```{r Car2Grupos}
housesTrain %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  select(car_cat) %>%
  table()

housesTrain %>% 
  na.omit() %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  select(Price, car_cat) %>%
  ggplot(aes(x=Price, colour=car_cat)) +
  geom_density()

housesTrain %>% 
  na.omit() %>%
  mutate(car_cat = cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE)) %>%
  mutate(log_price=log10(Price)) %>%
  select(log_price, car_cat) %>%
  ggplot(aes(x=log_price, colour=car_cat)) +
  geom_density()
```

__Distance y Price__

En vista de la siguiente gráfica, parece que las casas vendidas se concentran en distancias al centro menores de 15km.

```{r DistancePrice}
housesTrain %>%
  select('Distance', 'Price') %>%
  ggpairs
```

Tanto la variable *Distance* como la variable *Price* tienen sus valores concentrados en la parte baja de la distribución, por lo que una transformación logarítmica podría ser útil. Sin embargo, observamos que la variable *Distance* tiene unos pocos valores a 0, por lo que puede que sea más adecuado aplicar la raíz cuadrada como forma de transformación (los valores extremos no están tan alejados).

```{r Distance0}
housesTrain %>% filter(Distance == 0) %>% nrow
```


```{r TransfDistance}
housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(x=log_distance)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(fill= colorDensidad , alpha=.2)

housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(x=sqrt_distance)) +
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(fill= colorDensidad , alpha=.2)
```
```{r TransDistanceHist}
p1 <- housesTrain %>% select(Distance) %>%
  ggplot(aes(x=Distance)) + 
  geom_density()

p2 <- housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(x=log_distance)) +
  geom_density()

p3 <- housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(x=sqrt_distance)) +
  geom_density()

grid.arrange(p1, p2, p3, nrow=1)
```


```{r TransDistanceBox}
p1 <- housesTrain %>% select(Distance) %>%
  ggplot(aes(y=Distance)) + 
  geom_boxplot()

p2 <- housesTrain %>% select(Distance) %>%
  filter(Distance > 0) %>%
  mutate(log_distance = log10(Distance)) %>%
  ggplot(aes(y=log_distance)) +
  geom_boxplot()

p3 <- housesTrain %>% select(Distance) %>%
  mutate(sqrt_distance = sqrt(Distance)) %>%
  ggplot(aes(y=sqrt_distance)) +
  geom_boxplot()

grid.arrange(p1, p2, p3, nrow=1)
```

```{r message=FALSE}
housesTrainLog <- housesTrain %>%
  select('Distance', 'Price') %>%
  filter(Price > 0 & Distance > 0) %>%
  mutate(log_price = log10(Price), log_distance=log10(Distance))

 housesTrainLog %>%
  select(log_distance, Price) %>%
  ggpairs
```

También se puede probar una transformación Box-Cox para ver si hay una transformación mejor que la log para igualar la dispersión.

```{r warning=FALSE}
housesTrain %>% select(Distance) %>%
  symbox(~ Distance, data= .)
```

__Latitud, longitud y Price__

```{r LatLongPrice}
housesTrain %>%
  select('Lattitude', 'Longtitude', 'Price') %>%
  ggpairs
```

__Sell date__

Lo primero que hacemos con esta variable será extraer el año, ya que viene en formato dd/MM/yyyy, y probablemente el año nos proporcione más información acerca del precio de venta de la casa.


```{r CrearSellYear}
housesTrain$sellYear <- separate(housesTrain, Date, c('Day','Month', 'Year'), sep = '/')$Year
#housesTrain$sellYear <- factor(housesTrain$year, levels=c("2016", "2017"))
describe(housesTrain$sellYear)
```

```{r SellYearPrice}
housesTrain %>% select(c("Price", "sellYear")) %>%
  na.omit() %>%
  ggplot(aes(x=Price, colour=sellYear)) +
  geom_density()

housesTrain %>%
  select(sellYear, Price) %>%
  ggpairs
 
price2016 <- housesTrain %>% filter(sellYear==2016) %>% select(Price)
price2017 <- housesTrain %>% filter(sellYear==2017) %>% select(Price)

p1 <- ggplot(price2016, aes(x=Price)) + geom_histogram()
p2 <- ggplot(price2017, aes(x=Price)) + geom_histogram()

grid.arrange(p1, p2, nrow=1)
```

<br>

## Análisis exploratorio de datos faltantes

<br>

Hemos visto anteriormente que las variables *YearBuilt*, *BuildingArea* y *Car* tenían valores NAs, y que la variable *Landsize* tenía valores sospechosos (0).
Examinamos primero que % de los registros no tienen estos valores rellenos.

Observamos que cerca del 50% de los registros tienen la variable BuildingArea sin informar, mientras que el 40% no tienen la variable YearBuilt informada. Vemos además que en el 37% de los casos, BuildingArea y YearBuilt faltan simultáneamente. El % de registros con la variable Car vacía es muy pequeño. Además, tenemos 15% de 0 en la variable Landsize, lo que podríamos considerar como valores faltantes.

```{r HistFaltantes}
aggr_plot <- aggr(housesTrain, col=c('#666666','#E6AB02'), numbers=TRUE, sortVars=TRUE,
                  labels=names(housesTrain), cex.axis=0.6, gap=3, 
                  ylab=c("Histogram of missing data","Patrón de co-ocurrencia"))

```

La primera decisión que se toma es eliminar la variables *BuildingArea*. Dicha variable hace referencia al area o tamaño de un espacio puesto que los valores iguales a cero han de entenderse como datos faltantes. En este sentido para la variable *BuildingArea* hay un 95.3% de datos faltantes.

A modo de resumen respecto a los datos faltantes podemos decir que:

- Para la variable *BuildingArea*, el 47% de los valores (5145 de 10865) son NaNs, y el 0.11% son 0. En total, tendríamos 47.11% de valores informados, de los cuales la mayoría son 0.

- Para la variable *YearBuilt*, el 40% de los valores son NaNs.

- Para la variable *Landsize*, no hay NaNs, pero el 14.3% de los valores son 0.

- La variable *Car* tiene 49 valores faltantes (0.45%).

- Para la variable *CounculArea*, el 10% son desconocidos (1098)

__Relación entre BuildingArea y Landsize informados__

La variable *BuildingArea* podría ser de gran interés a la hora de predecir el precio de venta de una casa. Sin embargo, la gran cantidad de datos faltantes lleva a pensar que una técnica de imputación puede no ser recomendable. Como también se tiene la variable *Landsize*, se procede a comprobar si existe alguna relación entre los valores informados de *BuildingArea* y esta variable, ya que la podríamos utilizar por su bajo número de datos faltantes.

Gráficamente no se ve gran cosa (habría que pasar a log) pero parece que están correladas.
```{r}
housesTrain %>% select(BuildingArea, Landsize) %>% na.omit() %>% ggpairs()
```
```{r}
housesTrain %>% select(BuildingArea, Landsize) %>%
  na.omit() %>%
  filter(Landsize > 0 & BuildingArea > 0) %>%
  mutate(log_landsize = log10(Landsize), log_buildingArea = log10(BuildingArea)) %>%
  select(log_landsize, log_buildingArea) %>% ggpairs()
```
<br>

<<<<<<< HEAD
```{r}
housesTrain %>% filter(CouncilArea == '' | CouncilArea == 'Unavailable') %>% nrow
```


__BuildingArea__
>>>>>>> 750759500e0b4afb54f68937bbeea5d9f749edee

Los valores informados son muy dispares, con una gran cantidad de outliers. Hay 4 valores por encima de 2500 que nos dificultan mucho la visualización de los datos. Se podrían quitar, o hacer una transformación logarítmica para verlo mejor.
=======
__Landsize__
>>>>>>> 0e3fce4fa65f2209169123da7442e37f855c4e6f

Aparte de los valores a 0, esta variable presenta valores muy dispersos. Se puede probar una transformación para verla mejor.
```{r}
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
housesTrain %>% filter(is.na(Landsize)) %>% nrow
```
```{r}
housesLogLandsize <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  filter(Landsize > 0) %>%
  mutate(log_landsize = log10(Landsize)) 

housesLogLandsize %>%
  ggplot(aes(x=log_landsize)) +
  geom_density()
```
```{r}
housesTrain %>% select(Landsize) %>% na.omit() %>%
  symbox(~ Landsize, data= .)
```

Vamos a ver como se distribuyen los valores informados (y faltantes) en función de la localización (latitud y longitud).
```{r message=FALSE}
housesTrain %>% select(Lattitude, Longtitude, Landsize) %>%
  na.omit() %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Lattitude, Longtitude, Landsize, log_landsize) %>%
  ggpairs
```

```{r message=FALSE}
housesTrain %>% filter(is.na(Landsize)) %>% select(Distance,Lattitude, Longtitude, Price) %>% ggpairs()
```
```{r message=FALSE}
housesTrain %>% na.omit() %>% select(Distance,Lattitude, Longtitude, Price) %>% ggpairs()
```

Parece que los valores faltantes de *Landsize* tienen muchos de sus valores en valores bajos de *Lattitude*.
```{r}
housesTrain %>% select(Lattitude, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Lattitude, log_landsize) %>% marginplot()
```

Para la longitud, se distribuyen de forma parecida.
```{r}
housesTrain %>% select(Longtitude, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Longtitude, log_landsize) %>% marginplot()
```

<br>

Si además se examina en función de la distancia, se puede aprecia que los valores faltantes de *Landsize* se dan para valores bajos de *Distance*, es decir, para casas más cercanas al centro de la ciudad.
```{r}
housesTrain %>%
  select(Distance, Landsize) %>% marginplot()

housesTrain %>%
  mutate(log_landsize = log10(Landsize)) %>%
  select(Distance, log_landsize) %>% marginplot()
```

Si probamos a imputar con kNN los valores de *Landsize* en función de las coordenadas y la distancia, vemos que los nuevos valores no se alejan demasiado de las distribuciones iniciales.
```{r}
imputationsLandsize <- housesTrain %>% select(Lattitude, Longtitude, Distance, Landsize) %>% VIM::kNN(variable='Landsize')
```


```{r}
imputationsLandsize %>% select(Lattitude, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLandsize %>% select(Longtitude, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLandsize %>% select(Distance, Landsize, Landsize_imp) %>% marginplot(., delimiter = '_imp')
```
<br>

Se puede ver mejor si imputamos los valores del logaritmo de *Landsize*:
```{r}
imputationsLogLandsize <- housesTrain %>% mutate(log_landsize=log10(Landsize)) %>%
  select(Lattitude, Longtitude, Distance, log_landsize) %>% VIM::kNN(variable='log_landsize')
```
```{r}
imputationsLogLandsize %>% select(Lattitude, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLogLandsize %>% select(Longtitude, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
imputationsLogLandsize %>% select(Distance, log_landsize, log_landsize_imp) %>% marginplot(., delimiter = '_imp')
```

```{r message=FALSE}
housesTrain$Landsize_imp <- imputationsLandsize$Landsize
housesTrain %>% 
  mutate(log_landsize = log10(Landsize_imp)) %>%
  select(Lattitude, Longtitude, Distance, log_landsize, Price) %>%
  ggpairs
```

Comparamos la distribución de *Landsize* con valores informados con la generada a través de imputación.


```{r}
p1 <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  ggplot(aes(y=Landsize)) + 
  geom_boxplot()

p2 <- housesTrain %>% select(Landsize) %>%
  na.omit() %>%
  mutate(log_landsize = log10(Landsize)) %>%
  ggplot(aes(y=log_landsize)) +
  geom_boxplot()

p3 <- imputationsLandsize %>% select(Landsize) %>%
  ggplot(aes(y=Landsize)) + 
  geom_boxplot()

p4 <- imputationsLogLandsize %>% select(log_landsize) %>%
  ggplot(aes(y=log_landsize)) +
  geom_boxplot()

grid.arrange( p2, p4, nrow=1)
```
<br>

__Car__
Para la variable *Car*, solo hay 49 valores faltantes (0.45%). Al ser una variable numérica con valores discretos (solo toma valores enteros desde 0 hasta 8), no parece buena idea utilizar métodos de imputación por regresiones en base a otras variables.

Podemos por un lado tratar de imputarlas basándonos en otras variables y usando kNN:

```{r}
housesTrain %>% select(Rooms, Car)  %>% marginplot()
housesTrain %>% select(Rooms, Car) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
```


```{r}
housesTrain %>% select(YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% marginplot()
housesTrain %>% select(YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
```
```{r}
housesTrain %>% select(Distance, Car)%>% marginplot()
housesTrain %>% select(Distance, Car) %>% VIM::kNN() %>% marginplot(., delimiter = '_imp')
housesTrain %>% select(Distance, YearBuilt, Car) %>% filter(!is.na(YearBuilt)) %>% VIM::kNN() %>% select(Distance, Car, Car_imp) %>% marginplot(., delimiter = '_imp')
```

 
Otras dos opciones:
* Borrar esos 49 registros (a riesgo de poder perder algo de información).
* Transformar la variable a categórica e intentar imputar el factor.

<<<<<<< HEAD
```{r imputations}
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
housesTrain$BuildingArea[which(housesTrain$BuildingArea == 0)] <- NA

imputations <- housesTrain %>%
  select(BuildingArea, YearBuilt, Landsize, Car) %>%
  VIM::kNN()
```
Para las viviendas donde *CouncilArea* no está registrado, lo imputaremos utilizando la latitud y longitud.

```{r imputacionCouncilArea}
housesTrain$CouncilArea[which(housesTrain$CouncilArea == 'Unavailable')] <- NA
imputations <- housesTrain %>% select(CouncilArea, Lattitude, Longtitude) %>% VIM::kNN()
```

__BuildingArea__
=======
Categorizamos la variable (ya vimos que se puede dividir en 2 categorías con aproximadamente el mismo numero de muestras) y utilizamos la función *polyreg* del paquete MICE que permite imputar valores categóricos mediante una regresión politómica. Este método se basa en construir un modelo multinomial para las respuestas categóricas, realizar las predicciones para los valores faltantes y después añadir ruido a estas predicciones.
>>>>>>> 0e3fce4fa65f2209169123da7442e37f855c4e6f

```{r}
housesTrain$car_cat = housesTrain %>%
  mutate(car_cat = addNA(cut(Car, breaks = c(0,2,9), labels = c("0 o 1 plaza", "2 o más"), include.lowest = TRUE, right = FALSE))) %>%
  select(car_cat) 

housesTrain$rooms_cat = housesTrain%>% 
  mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("De 1 a 2", "3", "De 4 a 10"), include.lowest = TRUE, right = FALSE)) %>% select(rooms_cat) 
```

```{r}
housesTrain %>%
  mutate(car_cat = addNA(cut(Car, breaks = c(0,2,9), labels = c("De 0 a 1", "De 2 a 9"), include.lowest = TRUE, right = FALSE))) %>%
  select(car_cat) %>% table
```


```{r}
# ESTO NO ME SALE
library(mice)
cols <- c('rooms_cat', 'Regionname', 'car_cat')
car_imputed = mice(housesTrain[,cols], m=5, method='polyreg', seed=10)
```

Una vez imputado, previsiblemente no habrá cambiado la distribución de la variable al ser un % tan pequeño de datos faltantes.

__YearBuilt__
Al tener tantos registros sin informar, y ser una variable cuantitativa con una distribución que presenta varios tipos, se pretende transformar a una variable categórica que represente intervalos temporales, añadiendo una categoría Unknown a los valores faltantes.
```{r}
housesTrain %>% select(YearBuilt, Price) %>% na.omit() %>% ggpairs
```
Lo primero que hacemos es una rápida comprobación de valores informados. Vemos que hay un outlier en el año 1196. Se establece que cualquier casa que tenga *YearBuilt* por debajo del año de fundación de la ciudad será eliminada.
```{r}
housesTrain %>% select(YearBuilt, Price) %>% na.omit() %>%
  filter(YearBuilt >= 1850) %>% ggpairs
```

Después, se convierte a categórica, y se comprueba su relación con *Price*.

```{r}
year_categories <- housesTrain %>% 
  filter(YearBuilt >= 1850 | is.na(YearBuilt)) %>%
  mutate(year_cat = addNA(cut2(YearBuilt, g=3)))

year_categories %>%
  select(year_cat) %>% table()
```

```{r}
year_categories %>%
  select(Price, year_cat) %>%
  ggplot(aes(x=Price, colour=year_cat)) +
  geom_density()
```
```{r}
year_categories %>%
  select(Price, year_cat) %>%
  ggplot(aes(y=Price, fill=year_cat)) +
  geom_boxplot()
```


## Transformaciones y procesado de variables
A modo de resumen, se contemplan las siguientes transformaciones de las variables cuantitativas disponibles:
* Transformación logarítmica de *Landsize* y *Price* (variable target, cambiaría interpretabilidad, pero puede mejorar predicción)
* Transformación de raíz cuadrada de *Distance*
* Categorización de *Rooms*, *YearBuilt* y *Car*
* Reescalado de variables cuantitativas

```{r cuantitative_transformations}
# Filtros e imputaciones
#housesTrainFinal <- housesTrain
housesTrain$YearBuilt[which(housesTrain$YearBuilt<1850)] <- NA
housesTrain$Landsize[which(housesTrain$Landsize == 0)] <- NA
#imputationsLandsizeFinal <- housesTrain %>% select(Lattitude, Longtitude, Distance, Landsize) %>% VIM::kNN(variable='Landsize')
#imputationsCarFinal <- housesTrain %>% select(Rooms, Car) %>% VIM::kNN(variable='Car')

# Transformaciones de variables cuantitativas

housesTrain$sqrt_distance <- housesTrain %>% mutate(sqrt_distance = sqrt(Distance)) %>% select(sqrt_distance)
housesTrain$log_landsize <- imputationsLandsizeFinal %>% mutate(log_landsize=log10(Landsize)) %>% select(log_landsize)
housesTrain$log_price <- housesTrain %>% mutate(log_price = log10(Price)) %>% select(log_price)

# Discretización de variables cuantitativas
housesTrain$rooms_cat <- cut(housesTrain$Rooms,  breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE)

housesTrain$year_built_cat <- addNA(factor(cut2(housesTrain$YearBuilt, g=2), labels=c("Antigua", "Moderna")))

housesTrain$car_cat <-cut(imputationsCarFinal$Car, breaks = c(0,2,9), labels = c("Hasta 1 plaza", "2 o más plazas"), include.lowest = TRUE, right = FALSE)
```


```{r}
housesTrain$rooms_cat %>% table()
housesTrain$year_built_cat %>% table()
housesTrain$car_cat %>% table()
```

```{r}
levels(housesTrain$rooms_cat)
levels(housesTrain$year_built_cat)
levels(housesTrain$car_cat)
```


```{r message=FALSE}
# ESTO NO HARÍA FALTA SI LO ANTERIOR SE GUARDA BIEN
housesTrain %>% mutate(rooms_cat = cut(housesTrain$Rooms, breaks = c(1,3,4,10), labels = c("Pequeñas", "Medianas", "Grandes"), include.lowest = TRUE, right = FALSE), sqrt_distance = sqrt(Distance), log_price = log10(Price)) %>% select(sqrt_distance, log_price, rooms_cat) %>% ggpairs(columns=1:3, ggplot2::aes(colour=rooms_cat, alpha=0.1))
```
```{r}
housesTrain %>% mutate(sqrt_distance = sqrt(Distance), log_price = log10(Price)) %>% select(sqrt_distance, log_price, Type) %>% ggpairs(columns=1:3, ggplot2::aes(colour=Type, alpha=0.1))
```
```{r}
housesTrain %>% mutate(sqrt_distance = sqrt(Distance), log_price = log10(Price)) %>% select(sqrt_distance, log_price, Method) %>% ggpairs(columns=1:3, ggplot2::aes(colour=Method, alpha=0.1))
```

## Contrastes entre niveles de variables categóricas

```{r}
housesTrain %>% ggplot(aes(x=Distance, y=Price, colour=rooms_cat)) + geom_point()
```

__CouncilArea__




## Selección de variables
